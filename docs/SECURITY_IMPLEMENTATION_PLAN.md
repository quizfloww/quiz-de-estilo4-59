# üîí Plano de Implementa√ß√£o de Seguran√ßa - Quiz Sell Genius

## üéØ Objetivo

Resolver vulnerabilidades cr√≠ticas de seguran√ßa identificadas no projeto Quiz Sell Genius, migrando de um sistema de autentica√ß√£o mock para uma implementa√ß√£o segura e robusta.

## üö® Vulnerabilidades Cr√≠ticas Identificadas

### 1. **CR√çTICO: Sistema de Autentica√ß√£o Mock**

- **Arquivo**: `/src/context/AuthContext.tsx`
- **Problema**: Autentica√ß√£o baseada apenas em localStorage
- **Risco**: Qualquer usu√°rio pode obter acesso admin modificando localStorage
- **Impacto**: Comprometimento total do sistema administrativo

### 2. **ALTO: Uso Extensivo de localStorage para Dados Sens√≠veis**

- **Inst√¢ncias**: 202+ ocorr√™ncias em 63 arquivos
- **Dados Expostos**:
  - `userName`, `userEmail`, `userRole`
  - Tokens fict√≠cios
  - Configura√ß√µes de neg√≥cio
  - Dados de analytics

### 3. **M√âDIO: Exposi√ß√£o de Chaves API**

- **Localiza√ß√£o**: C√≥digo JavaScript compilado
- **Problema**: Chaves de API vis√≠veis no cliente

### 4. **M√âDIO: Aus√™ncia de Valida√ß√£o e Prote√ß√£o**

- Sem valida√ß√£o de entrada
- Sem prote√ß√£o CSRF
- Sem sanitiza√ß√£o XSS
- Sem rate limiting

## üìã FASE 1: Autentica√ß√£o Real com Supabase (CR√çTICA)

### 1.1 Configura√ß√£o do Supabase

```bash
# Instalar depend√™ncias
npm install @supabase/supabase-js @supabase/auth-helpers-nextjs

# Configurar vari√°veis de ambiente
echo "NEXT_PUBLIC_SUPABASE_URL=sua_url_supabase" >> .env.local
echo "NEXT_PUBLIC_SUPABASE_ANON_KEY=sua_chave_anonima" >> .env.local
echo "SUPABASE_SERVICE_ROLE_KEY=sua_chave_service_role" >> .env.local
```

### 1.2 Substituir AuthContext Mock

**Arquivo**: `/src/context/AuthContext.tsx`

```typescript
import { createContext, useContext, useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { User, Session } from "@supabase/supabase-js";

interface AuthContextType {
  user: User | null;
  session: Session | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<{ error?: any }>;
  signUp: (email: string, password: string) => Promise<{ error?: any }>;
  signOut: () => Promise<void>;
  isAdmin: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const [isAdmin, setIsAdmin] = useState(false);

  const supabase = createClientComponentClient();

  useEffect(() => {
    // Verificar sess√£o atual
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      checkAdminRole(session?.user);
      setLoading(false);
    });

    // Escutar mudan√ßas de autentica√ß√£o
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      setSession(session);
      setUser(session?.user ?? null);
      checkAdminRole(session?.user);
      setLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  const checkAdminRole = async (user: User | null) => {
    if (!user) {
      setIsAdmin(false);
      return;
    }

    try {
      const { data, error } = await supabase
        .from("user_roles")
        .select("role")
        .eq("user_id", user.id)
        .single();

      setIsAdmin(data?.role === "admin");
    } catch (error) {
      console.error("Erro ao verificar papel do usu√°rio:", error);
      setIsAdmin(false);
    }
  };

  const signIn = async (email: string, password: string) => {
    setLoading(true);
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    setLoading(false);
    return { error };
  };

  const signUp = async (email: string, password: string) => {
    setLoading(true);
    const { error } = await supabase.auth.signUp({
      email,
      password,
    });
    setLoading(false);
    return { error };
  };

  const signOut = async () => {
    setLoading(true);
    await supabase.auth.signOut();
    setLoading(false);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        loading,
        signIn,
        signUp,
        signOut,
        isAdmin,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth deve ser usado dentro de AuthProvider");
  }
  return context;
};
```

### 1.3 Atualizar AdminRoute com Verifica√ß√£o Real

**Arquivo**: `/src/components/admin/AdminRoute.tsx`

```typescript
import React from "react";
import { Navigate } from "react-router-dom";
import { useAuth } from "@/context/AuthContext";

interface AdminRouteProps {
  children: React.ReactNode;
  requireAdmin?: boolean;
}

export const AdminRoute: React.FC<AdminRouteProps> = ({
  children,
  requireAdmin = true,
}) => {
  const { user, loading, isAdmin } = useAuth();

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (requireAdmin && !isAdmin) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">
            Acesso Negado
          </h2>
          <p className="text-gray-600 mb-4">
            Voc√™ n√£o tem permiss√£o para acessar esta √°rea administrativa.
          </p>
          <button
            onClick={() => window.history.back()}
            className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
          >
            Voltar
          </button>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};
```

### 1.4 Configura√ß√£o do Banco de Dados

**SQL para Supabase**:

```sql
-- Tabela para pap√©is de usu√°rios
CREATE TABLE user_roles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    role varchar(50) NOT NULL DEFAULT 'user',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id)
);

-- RLS (Row Level Security)
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;

-- Pol√≠tica para usu√°rios verem apenas seu pr√≥prio papel
CREATE POLICY "Users can view own role" ON user_roles
    FOR SELECT USING (auth.uid() = user_id);

-- Pol√≠tica para admins gerenciarem pap√©is
CREATE POLICY "Admins can manage roles" ON user_roles
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

-- Fun√ß√£o para verificar se usu√°rio √© admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM user_roles
        WHERE user_id = auth.uid() AND role = 'admin'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Configura√ß√µes de quiz seguras
CREATE TABLE quiz_configurations (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name varchar(255) NOT NULL,
    config jsonb NOT NULL,
    created_by uuid REFERENCES auth.users(id),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

ALTER TABLE quiz_configurations ENABLE ROW LEVEL SECURITY;

-- Apenas admins podem gerenciar configura√ß√µes
CREATE POLICY "Only admins can manage quiz configs" ON quiz_configurations
    FOR ALL USING (is_admin());

-- Resultados de quiz an√¥nimos
CREATE TABLE quiz_results (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id varchar(255),
    result_data jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    ip_address inet,
    user_agent text
);

ALTER TABLE quiz_results ENABLE ROW LEVEL SECURITY;

-- Pol√≠tica para inser√ß√£o an√¥nima
CREATE POLICY "Allow anonymous quiz result insertion" ON quiz_results
    FOR INSERT WITH CHECK (true);

-- Apenas admins podem ver resultados
CREATE POLICY "Only admins can view quiz results" ON quiz_results
    FOR SELECT USING (is_admin());
```

## üìã FASE 2: Migra√ß√£o de localStorage para Banco Seguro

### 2.1 Criar Hooks Seguros para Dados

**Arquivo**: `/src/hooks/useSecureStorage.ts`

```typescript
import { useAuth } from "@/context/AuthContext";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { useCallback, useEffect, useState } from "react";

export const useSecureQuizConfig = () => {
  const { user, isAdmin } = useAuth();
  const [configs, setConfigs] = useState([]);
  const [loading, setLoading] = useState(false);
  const supabase = createClientComponentClient();

  const saveConfig = useCallback(
    async (name: string, config: any) => {
      if (!isAdmin) throw new Error("Acesso negado");

      setLoading(true);
      try {
        const { data, error } = await supabase
          .from("quiz_configurations")
          .upsert({
            name,
            config,
            created_by: user?.id,
          })
          .select();

        if (error) throw error;
        return data[0];
      } finally {
        setLoading(false);
      }
    },
    [user, isAdmin, supabase]
  );

  const loadConfigs = useCallback(async () => {
    if (!isAdmin) return;

    setLoading(true);
    try {
      const { data, error } = await supabase
        .from("quiz_configurations")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      setConfigs(data || []);
    } finally {
      setLoading(false);
    }
  }, [isAdmin, supabase]);

  return { configs, saveConfig, loadConfigs, loading };
};

export const useSecureQuizResults = () => {
  const supabase = createClientComponentClient();

  const saveResult = useCallback(
    async (resultData: any, sessionId?: string) => {
      const { data, error } = await supabase
        .from("quiz_results")
        .insert({
          session_id: sessionId || crypto.randomUUID(),
          result_data: resultData,
          ip_address: null, // Ser√° preenchido pelo servidor
          user_agent: navigator.userAgent,
        })
        .select();

      if (error) throw error;
      return data[0];
    },
    [supabase]
  );

  return { saveResult };
};
```

### 2.2 Middleware de Seguran√ßa

**Arquivo**: `/src/middleware/security.ts`

```typescript
import { createMiddlewareClient } from "@supabase/auth-helpers-nextjs";
import { NextRequest, NextResponse } from "next/server";

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });

  // Verificar sess√£o
  const {
    data: { session },
  } = await supabase.auth.getSession();

  // Proteger rotas administrativas
  if (req.nextUrl.pathname.startsWith("/admin")) {
    if (!session) {
      return NextResponse.redirect(new URL("/login", req.url));
    }

    // Verificar se √© admin
    const { data: userRole } = await supabase
      .from("user_roles")
      .select("role")
      .eq("user_id", session.user.id)
      .single();

    if (userRole?.role !== "admin") {
      return NextResponse.redirect(new URL("/unauthorized", req.url));
    }
  }

  // Headers de seguran√ßa
  res.headers.set("X-Frame-Options", "DENY");
  res.headers.set("X-Content-Type-Options", "nosniff");
  res.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
  res.headers.set("X-XSS-Protection", "1; mode=block");
  res.headers.set(
    "Content-Security-Policy",
    "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; connect-src 'self' https:;"
  );

  return res;
}

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};
```

## üìã FASE 3: Valida√ß√£o e Sanitiza√ß√£o

### 3.1 Esquemas de Valida√ß√£o

**Arquivo**: `/src/lib/validation.ts`

```typescript
import { z } from "zod";

export const QuizAnswerSchema = z.object({
  questionId: z.string().uuid(),
  selectedOptions: z.array(z.string()).min(1),
  timestamp: z.number().positive(),
});

export const QuizResultSchema = z.object({
  answers: z.array(QuizAnswerSchema),
  sessionId: z.string().uuid(),
  userAgent: z.string().max(500),
  completedAt: z.string().datetime(),
});

export const QuizConfigSchema = z.object({
  name: z.string().min(1).max(255),
  questions: z.array(
    z.object({
      id: z.string().uuid(),
      text: z.string().min(1),
      options: z.array(z.string().min(1)),
    })
  ),
  settings: z.object({
    timeLimit: z.number().positive().optional(),
    randomizeQuestions: z.boolean().default(false),
  }),
});

export const UserInputSchema = z.object({
  email: z.string().email(),
  name: z
    .string()
    .min(1)
    .max(100)
    .regex(/^[a-zA-Z√Ä-√ø\s]+$/),
  message: z.string().max(1000).optional(),
});
```

### 3.2 Utilit√°rios de Sanitiza√ß√£o

**Arquivo**: `/src/lib/sanitization.ts`

```typescript
import DOMPurify from "isomorphic-dompurify";

export const sanitizeHtml = (dirty: string): string => {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ["b", "i", "em", "strong", "p", "br"],
    ALLOWED_ATTR: [],
  });
};

export const sanitizeUserInput = (input: string): string => {
  return input
    .trim()
    .replace(/[<>\"'&]/g, "") // Remove caracteres perigosos
    .substring(0, 1000); // Limita tamanho
};

export const generateSecureId = (): string => {
  return crypto.randomUUID();
};

export const validateCSRFToken = (
  token: string,
  sessionToken: string
): boolean => {
  // Implementar valida√ß√£o CSRF adequada
  return token === sessionToken;
};
```

## üìã FASE 4: Implementa√ß√£o de Rate Limiting

### 4.1 Rate Limiting com Redis

**Arquivo**: `/src/lib/rateLimit.ts`

```typescript
import { Redis } from "@upstash/redis";

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

interface RateLimitOptions {
  key: string;
  limit: number;
  window: number; // em segundos
}

export async function rateLimit({ key, limit, window }: RateLimitOptions) {
  const now = Date.now();
  const pipeline = redis.pipeline();

  pipeline.zremrangebyscore(key, 0, now - window * 1000);
  pipeline.zadd(key, { score: now, member: now });
  pipeline.zcount(key, 0, "+inf");
  pipeline.expire(key, window);

  const results = await pipeline.exec();
  const count = results[2] as number;

  return {
    success: count <= limit,
    remaining: Math.max(0, limit - count),
    reset: new Date(now + window * 1000),
  };
}

// Middleware para API routes
export function withRateLimit(limit: number, window: number) {
  return async (req: any, res: any, next: any) => {
    const ip = req.ip || req.connection.remoteAddress;
    const result = await rateLimit({
      key: `rate_limit:${ip}`,
      limit,
      window,
    });

    if (!result.success) {
      return res.status(429).json({
        error: "Too many requests",
        retryAfter: result.reset,
      });
    }

    return next();
  };
}
```

## üìã Cronograma de Implementa√ß√£o

### **Semana 1: CR√çTICO**

- [x] Configurar Supabase
- [x] Implementar AuthContext real
- [x] Atualizar AdminRoute
- [x] Migrar primeira funcionalidade cr√≠tica

### **Semana 2: ALTO**

- [ ] Migrar todo localStorage para banco
- [ ] Implementar middleware de seguran√ßa
- [ ] Adicionar valida√ß√£o de entrada

### **Semana 3: M√âDIO**

- [ ] Implementar rate limiting
- [ ] Adicionar sanitiza√ß√£o XSS
- [ ] Configurar CSP headers

### **Semana 4: MONITORAMENTO**

- [ ] Implementar logging de seguran√ßa
- [ ] Configurar alertas
- [ ] Testes de penetra√ß√£o b√°sicos

## üîç Verifica√ß√£o e Testes

### Checklist de Seguran√ßa

- [ ] ‚úÖ Autentica√ß√£o real implementada
- [ ] ‚úÖ Dados sens√≠veis fora do localStorage
- [ ] ‚úÖ Valida√ß√£o de entrada ativa
- [ ] ‚úÖ Prote√ß√£o CSRF implementada
- [ ] ‚úÖ Rate limiting configurado
- [ ] ‚úÖ Headers de seguran√ßa ativos
- [ ] ‚úÖ Logs de auditoria funcionando

### Comandos de Teste

```bash
# Testar autentica√ß√£o
npm run test:auth

# Verificar headers de seguran√ßa
curl -I https://seudominio.com

# Testar rate limiting
for i in {1..10}; do curl https://seudominio.com/api/quiz; done

# Escanear vulnerabilidades
npm audit
```

## üö® A√ß√µes Imediatas Recomendadas

1. **IMPLEMENTAR IMEDIATAMENTE**: Nova autentica√ß√£o com Supabase
2. **MIGRAR URGENTE**: Dados do localStorage para banco seguro
3. **CONFIGURAR**: Headers de seguran√ßa b√°sicos
4. **MONITORAR**: Logs de acesso administrativo

---

**‚ö†Ô∏è ALERTA**: O sistema atual est√° vulner√°vel a ataques b√°sicos. A implementa√ß√£o dessas medidas √© CR√çTICA para a seguran√ßa do neg√≥cio.
